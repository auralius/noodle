#!/usr/bin/env python3
"""
txt2h.py â€” Convert a whitespace/newline separated numeric .txt file into a C/C++ header (.h).

Typical use (Noodle-style weights):
  python3 txt2h.py w19.txt --name w19 --out w19.h

The input may contain:
  - one number per line (recommended)
  - extra tokens per line (we take the first float-like token)
  - scientific notation (e.g., 1.23e-4)

Outputs:
  - const float <name>[N] = { ... };
  - optional PROGMEM placement (AVR/Arduino)
"""

from __future__ import annotations
import argparse
import datetime
import re
from pathlib import Path
from typing import List

_FLOAT_RE = re.compile(r'[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?')

def c_float_literal(x: float) -> str:
    # Optional polish: avoid "-0.0f"
    if x == 0.0:
        return "0.0f"

    s = f"{x:.9g}"  # compact but accurate enough for weights
    # Ensure it's a valid floating literal before adding 'f'
    if "e" not in s and "E" not in s and "." not in s:
        s += ".0"
    return s + "f"

def read_numbers(path: Path) -> List[float]:
    nums: List[float] = []
    with path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            # allow commas as separators
            s = s.replace(",", " ")
            m = _FLOAT_RE.search(s)
            if m:
                nums.append(float(m.group(0)))
    if not nums:
        raise ValueError(f"No numeric values found in {path}")
    return nums

def to_guard(name: str) -> str:
    g = re.sub(r'[^0-9A-Za-z]+', '_', name).strip('_').upper()
    if not g:
        g = "TXT2H_OUT"
    return f"{g}_H"

def emit_header(nums: List[float], *, name: str, dtype: str, progmem: bool,
                include_arduino: bool, columns: int) -> str:
    guard = to_guard(name)
    lines: List[str] = []
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")
    if include_arduino:
        lines.append("#include <stdint.h>")
        if progmem:
            lines.append("#include <avr/pgmspace.h>")
        lines.append("")
    n = len(nums)
    lines.append(f"// Auto-generated by txt2h.py on {datetime.datetime.now().isoformat(timespec='seconds')}")
    lines.append(f"// Source count: {n}")
    lines.append("")
    prog = " PROGMEM" if progmem else ""
    lines.append(f"const {dtype} {name}[{n}]{prog} = {{")
    for i in range(0, n, columns):
        chunk = nums[i:i+columns]
        if dtype == "float":
            row = ", ".join(c_float_literal(x) for x in chunk)
        else:
            row = ", ".join(f"{x:.9g}" for x in chunk)
        lines.append(f"  {row},")
    lines.append("};")
    lines.append("")
    lines.append(f"#define {name.upper()}_LEN ({n}u)")
    lines.append("")
    lines.append(f"#endif // {guard}")
    return "\n".join(lines)

def main() -> int:
    ap = argparse.ArgumentParser(description="Convert numeric .txt to a C/C++ header (.h)")
    ap.add_argument("inp", type=Path, help="Input .txt file with numbers")
    ap.add_argument("--out", type=Path, default=None, help="Output .h path (default: <inp>.h)")
    ap.add_argument("--name", default=None, help="C array name (default: stem of input filename)")
    ap.add_argument("--dtype", default="float", choices=["float", "double"], help="C element type")
    ap.add_argument("--progmem", action="store_true", help="Add PROGMEM (AVR/Arduino). Adds <avr/pgmspace.h> include.")
    ap.add_argument("--no-arduino-includes", action="store_true", help="Do not include Arduino-ish headers")
    ap.add_argument("--columns", type=int, default=8, help="How many values per line in the initializer")
    args = ap.parse_args()

    inp: Path = args.inp
    out: Path = args.out if args.out is not None else inp.with_suffix(".h")
    name: str = args.name if args.name is not None else inp.stem

    nums = read_numbers(inp)
    header = emit_header(nums, name=name, dtype=args.dtype, progmem=args.progmem,
                         include_arduino=not args.no_arduino_includes, columns=max(1, args.columns))
    out.write_text(header, encoding="utf-8")
    print(f"Wrote {out}  (N={len(nums)})")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
