#include <Arduino.h>
#include "noodle.h"

// ------------------------------------------------------------
// Exported parameters (generated by your Python exporter)
// ------------------------------------------------------------
// Weights
#include "w01.h"   // stem conv3x3 (1->8)
#include "w02.h"   // B1 DW3x3 (8ch)
#include "w03.h"   // B1 PW1x1 (8->8)
#include "w04.h"   // B2 DW3x3 (8ch)
#include "w05.h"   // B2 PW1x1 (8->8)
#include "w06.h"   // B3 DW3x3 s2 (8ch)
#include "w07.h"   // B3 PW1x1 (8->16)
#include "w08.h"   // B4 DW3x3 (16ch)
#include "w09.h"   // B4 PW1x1 (16->16)
#include "w10.h"   // B5 DW3x3 s2 (16ch)
#include "w11.h"   // B5 PW1x1 (16->24)
#include "w12.h"   // B6 DW3x3 (24ch)
#include "w13.h"   // B6 PW1x1 (24->24)
#include "w14.h"   // Dense (24->10)  (exporter should make this [10,24] row-major)

// Biases
#include "b01.h"   // stem conv bias (8)
#include "b02.h"   // Dense bias (10)  (if your exporter names this differently, adjust here)

// BatchNorm packed as: [gamma(C), beta(C), mean(C), var(C)] (use noodle_bn(x,C,W,bnXX,eps))
#include "bn01.h"  // stem_bn (C=8)
#include "bn02.h"  // B1_dw_bn (C=8)
#include "bn03.h"  // B1_pw_bn (C=8)
#include "bn04.h"  // B2_dw_bn (C=8)
#include "bn05.h"  // B2_pw_bn (C=8)
#include "bn06.h"  // B3_dw_bn (C=8)
#include "bn07.h"  // B3_pw_bn (C=16)
#include "bn08.h"  // B4_dw_bn (C=16)
#include "bn09.h"  // B4_pw_bn (C=16)
#include "bn10.h"  // B5_dw_bn (C=16)
#include "bn11.h"  // B5_pw_bn (C=24)
#include "bn12.h"  // B6_dw_bn (C=24)
#include "bn13.h"  // B6_pw_bn (C=24)

// ------------------------------------------------------------
// Serial RX protocol settings
// ------------------------------------------------------------
static const uint32_t BAUD = 115200;
static const uint32_t RX_TIMEOUT_MS = 3000;

static const uint16_t IMG_W = 28;
static const uint16_t IMG_H = 28;
static const uint16_t IMG_SIZE = IMG_W * IMG_H;

#define NORMALIZE_0_1

// Uncomment if you want input normalized to [0,1]
// #define NORMALIZE_0_1

// ------------------------------------------------------------
// Buffers
// ------------------------------------------------------------
// Max activation in this net is 28*28*8 (not 28*28*24).
static const uint32_t MAX_FEAT_FLOATS = (uint32_t)28 * 28 * 8;  // 6272

static float *FEAT_A = nullptr;   // ping
static float *FEAT_B = nullptr;   // pong

//static uint8_t RX_BYTES[IMG_SIZE] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,255,253,253,253,124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,180,253,251,251,251,251,145,62,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,217,241,253,251,251,251,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37,251,251,253,251,251,251,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,166,251,251,253,251,96,148,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,253,253,253,253,130,0,0,110,253,255,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,251,251,251,251,0,0,0,109,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,202,251,251,251,225,0,0,6,129,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,251,251,251,71,0,0,115,251,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,251,251,173,20,0,0,217,251,251,253,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,182,255,253,216,0,0,0,0,218,253,253,182,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,221,253,251,215,0,0,0,84,236,251,251,77,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,251,253,251,215,0,0,11,160,251,251,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,251,253,251,137,0,0,150,251,251,251,71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,251,253,251,35,0,130,253,251,251,173,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,253,255,253,98,150,253,255,253,164,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,251,253,251,251,251,251,253,251,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,93,241,253,251,251,251,251,216,112,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,253,251,251,251,251,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,124,251,225,71,71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static uint8_t RX_BYTES[IMG_SIZE];

// Forward decl
static bool recv_exact(uint8_t *dst, size_t n, uint32_t timeout_ms);
static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n);


// ------------------------------------------------------------
// Depthwise + Pointwise block (ping-pong):
//   DW:  in -> out  (+ BN + ReLU in-place on out)
//   PW:  out -> in  (+ BN + ReLU in-place on in)
// Final output lives in 'in'.
// ------------------------------------------------------------
uint16_t    noodle_dw_pw_block(float *in, float *out,
                            uint16_t W_in,
                            uint16_t Cin,
                            uint16_t Cout,
                            uint16_t stride_dw,
                            const float *w_dw, const float *bn_dw,
                            const float *w_pw, const float *bn_pw)
{
  const float BN_EPS = 1e-3f;   // match Keras default
  Pool none{}; // M=1,T=1 by default

  // DW (Cin -> Cin)
  ConvMem dw{}; 
  dw.K = 3; dw.P = 1; dw.S = stride_dw;
  dw.weight = w_dw; 
  dw.bias   = nullptr; 
  dw.act    = ACT_NONE;
  uint16_t W = noodle_dwconv_float(in, Cin, out, W_in, dw, none, nullptr);
  noodle_bn_relu(out, Cin, W, bn_dw, BN_EPS);  

  // PW (Cin -> Cout)
  ConvMem pw{}; 
  pw.K = 1; pw.P = 0; pw.S = 1;
  pw.weight = w_pw; 
  pw.bias   = nullptr; 
  pw.act    = ACT_NONE;
  W = noodle_conv_float(out, Cin, Cout, in, W, pw, none, nullptr);
  noodle_bn_relu(in, Cout, W, bn_pw, BN_EPS);
  return W;
}


static void alloc_buffers()
{
  FEAT_A = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));
  FEAT_B = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));

  if (!FEAT_A || !FEAT_B) {
    Serial.println(F("ERROR: malloc failed (out of RAM)"));
    while (true) delay(1000);
  }
}

// ------------------------------------------------------------
// Inference
// ------------------------------------------------------------
void predict()
{
  const unsigned long t0 = micros();

  // ---- Input ----
  // FEAT_A holds input image in CHW where C=1, W=28: [1][28][28]

  // ---- No Pooling ----
  Pool none{}; none.M = 1; none.T = 1;

  // ---- Stem: Conv3x3 (1->8) + BN + ReLU ----
  ConvMem stem{};
  stem.K = 3; stem.P = 1; stem.S = 1;
  stem.weight = w01;
  stem.bias   = b01;
  stem.act    = ACT_NONE;

  // ---- Dense: 24 -> 10 ----
  FCNMem head{};
  head.weight = w14;   // row-major [10,24]
  head.bias   = b02;   // 10
  head.act    = ACT_NONE;

  uint16_t W = noodle_conv_float(FEAT_A, 1, 8, FEAT_B, 28, stem, none, nullptr);  
  noodle_bn_relu(FEAT_B, 8, W, bn01, 1e-3f);

  // Ping-pong buffers
  float *in  = FEAT_B;
  float *out = FEAT_A;

  // ---- B1 (8->8, stride 1) ----
  W = noodle_dw_pw_block(in, out, W, 8, 8, 1, w02, bn02, w03, bn03);
  // ---- B2 (8->8, stride 1) ----
  W = noodle_dw_pw_block(in, out, W, 8, 8, 1, w04, bn04, w05, bn05);
  // ---- B3 (8->16, stride 2) ----
  W = noodle_dw_pw_block(in, out, W, 8, 16, 2, w06, bn06, w07, bn07);
  // ---- B4 (16->16, stride 1) ----
  W = noodle_dw_pw_block(in, out, W, 16, 16, 1, w08, bn08, w09, bn09);
  // ---- B5 (16->24, stride 2) ----
  W = noodle_dw_pw_block(in, out, W, 16, 24, 2, w10, bn10, w11, bn11);
  // ---- B6 (24->24, stride 1) ----
  W = noodle_dw_pw_block(in, out, W, 24, 24, 1, w12, bn12, w13, bn13);
  // ---- GAP: (W x W x 24) -> (24,) in-place ----
  W = noodle_gap(in, 24, W);
  // ---- Dense: (24,) -> (10,) ----
  W = noodle_fcn(in, W, 10, out, head, nullptr);
  // Softmax in-place on logits
  noodle_soft_max(out, 10);

  // Argmax
  uint16_t pred;
  float max_val;
  noodle_find_max(out, 10, max_val, pred);

  const float et = (float)(micros() - t0) * 1e-6f;

  // Python-friendly:
  // PRED <digit> <seconds> <p_max>
  Serial.print(F("PRED "));
  Serial.print(pred);
  Serial.print(' ');
  Serial.print(et, 4);
  Serial.print(' ');
  Serial.print(max_val, 4);
  
  Serial.println();
}

// ------------------------------------------------------------
// Arduino
// ------------------------------------------------------------
void setup()
{
  Serial.begin(BAUD);
  delay(200);
  while (Serial.available()) Serial.read();

  alloc_buffers();

  Serial.println(F("READY"));
  delay(1000);

  bytes_to_float_image(RX_BYTES, FEAT_A, IMG_SIZE);
  predict();
}

void loop()
{
  if (!recv_exact(RX_BYTES, IMG_SIZE, RX_TIMEOUT_MS)) {
    Serial.println(F("READY"));
    return;
   }
  bytes_to_float_image(RX_BYTES, FEAT_A, IMG_SIZE);
  predict();
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------
static bool recv_exact(uint8_t *dst, size_t n, uint32_t timeout_ms)
{
  uint32_t t0 = millis();
  size_t got = 0;

  while (got < n) {
    if ((millis() - t0) > timeout_ms) return false;

    int avail = Serial.available();
    if (avail <= 0) { delay(1); continue; }

    int r = Serial.readBytes((char *)(dst + got), n - got);
    if (r > 0) got += (size_t)r;
  }
  return true;
}

static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n)
{
#ifdef NORMALIZE_0_1
  const float inv = 1.0f / 255.0f;
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i] * inv;
#else
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i];
#endif
}
