// Darla's model, generted by AutoKeras

#include <Arduino.h>
#include "noodle.h"

// ------------------------------------------------------------
// Exported parameters (generated by your Python exporter)
// ------------------------------------------------------------
// Weights
#include "pneumonia/w01.h"   
#include "pneumonia/w02.h"   
#include "pneumonia/w03.h"  

// Biases
#include "pneumonia/b01.h"   
#include "pneumonia/b02.h"   
#include "pneumonia/b03.h"   

// ------------------------------------------------------------
// Serial RX protocol settings
// ------------------------------------------------------------
static const uint16_t RX_TIMEOUT_MS = 3000;

static const uint16_t IMG_W = 64;
static const uint16_t IMG_H = 64;
static const uint16_t IMG_C = 3;
static const uint16_t IMG_SIZE = IMG_W * IMG_H * IMG_C; // CHW bytes: C planes stacked

// Uncomment if you want input normalized to [0,1]
#define NORMALIZE_0_1

// ------------------------------------------------------------
// Buffers
// ------------------------------------------------------------
// Max activation in this net is 64 * 64 * 8.
static const uint16_t MAX_FEAT_FLOATS = (uint16_t)64 * 64 * 8;  

static float *A = nullptr;   // ping
static float *B = nullptr;   // pong

static uint8_t RX_BYTES[IMG_SIZE];

// Forward decl
static bool recv_exact(uint8_t *dst, size_t n, unsigned long timeout_ms);
static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n);


// ------------------------------------------------------------
// Depthwise + Pointwise block (ping-pong):
//   DW:  in -> out  (+ BN + ReLU in-place on out)
//   PW:  out -> in  (+ BN + ReLU in-place on in)
// Final output lives in 'in'.
// ------------------------------------------------------------
uint16_t    noodle_dw_pw_block(float *in, float *out,
                            uint16_t W_in,
                            uint16_t Cin,
                            uint16_t Cout,
                            uint16_t stride_dw,
                            const float *w_dw, const float *bn_dw,
                            const float *w_pw, const float *bn_pw)
{
  const float BN_EPS = 1e-3f;   // match Keras default
  Pool none{}; // M=1,T=1 by default

  // DW (Cin -> Cin)
  ConvMem dw{}; 
  dw.K = 3; dw.P = 1; dw.S = stride_dw;
  dw.weight = w_dw; 
  dw.bias   = nullptr; 
  dw.act    = ACT_NONE;
  uint16_t W = noodle_dwconv_float(in, Cin, out, W_in, dw, none, nullptr);
  noodle_bn_relu(out, Cin, W, bn_dw, BN_EPS);  

  // PW (Cin -> Cout)
  ConvMem pw{}; 
  pw.K = 1; pw.P = 0; pw.S = 1;
  pw.weight = w_pw; 
  pw.bias   = nullptr; 
  pw.act    = ACT_NONE;
  W = noodle_conv_float(out, Cin, Cout, in, W, pw, none, nullptr);
  noodle_bn_relu(in, Cout, W, bn_pw, BN_EPS);
  return W;
}


static void alloc_buffers()
{
  A = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));
  B = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));

  if (!A || !B) {
    Serial.println(F("ERROR: malloc failed (out of RAM)"));
    while (true) delay(1000);
  }
}

// ------------------------------------------------------------
// Inference
// ------------------------------------------------------------
void predict()
{
  const unsigned long t0 = micros();

  // ---- No Pooling ----
  Pool none{}; none.M = 1; none.T = 1;
  Pool v1{}; v1.M = 2; v1.T = 2;

  // ---- Stem: Conv3x3 (3->8) + BN + ReLU ----
  ConvMem c1{};
  c1.K = 3; c1.P = 1; c1.S = 1;
  c1.weight = w01;
  c1.bias   = b01;
  c1.act    = ACT_NONE;

  ConvMem c2{};
  c2.K = 3; c2.P = 0; c2.S = 1;
  c2.weight = w02;
  c2.bias   = b02;
  c2.act    = ACT_NONE;

  FCNMem head{};
  head.weight = w03;
  head.bias = b03;
  head.act = ACT_NONE;
  
  // Ping-pong buffers
  
  uint16_t V = 0;
  V = noodle_conv_float(A, 3, 8, B, 64, c1, none, nullptr); // check if V == 64
  V = noodle_conv_float(B, 8, 8, A, V, c2, none, nullptr); // check if V == 60
  V = noodle_valid_max_pool(A, 2, 2, v1); // check if V == 30 
  V = noodle_flat(B, A, V, 8); // check if V == 7200 
  V = noodle_fcn(A, V, 1, B, head, nullptr);
  
  // In-place logit
  noodle_logit(B, 8);

  // Argmax
  uint16_t pred;
  float max_val;
  noodle_find_max(B, 8, max_val, pred);

  const float et = (float)(micros() - t0) * 1e-6f;

  // Python-friendly:
  // PRED <digit> <seconds> <p_max>
  Serial.print(F("PRED "));
  Serial.print(pred);
  Serial.print(' ');
  Serial.print(et, 4);
  Serial.print(' ');
  Serial.print(max_val, 4);
  
  Serial.println();
}

// ------------------------------------------------------------
// Arduino
// ------------------------------------------------------------
void setup()
{
  Serial.begin(115200);
  delay(200);
  while (Serial.available()) Serial.read();

  alloc_buffers();

  Serial.println(F("READY"));
  // Wait for the first frame from the host.
}

void loop()
{
  if (!recv_exact(RX_BYTES, IMG_SIZE, RX_TIMEOUT_MS)) {
    Serial.println(F("READY"));
    return;
   }
  bytes_to_float_image(RX_BYTES, A, IMG_SIZE);
  predict();
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------
static bool recv_exact(uint8_t *dst, size_t n, unsigned long timeout_ms)
{
  unsigned long t0 = millis();
  size_t got = 0;

  while (got < n) {
    if ((millis() - t0) > timeout_ms) return false;

    int avail = Serial.available();
    if (avail <= 0) { delay(1); continue; }

    int r = Serial.readBytes((char *)(dst + got), n - got);
    if (r > 0) got += (size_t)r;
  }
  return true;
}

static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n)
{
#ifdef NORMALIZE_0_1
  const float inv = 1.0f / 255.0f;
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i] * inv;
#else
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i];
#endif
}
