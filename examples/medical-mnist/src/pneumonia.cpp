// Darla's model, generted by AutoKeras

#include <Arduino.h>
#include "noodle.h"

// ------------------------------------------------------------
// Exported parameters (generated by your Python exporter)
// ------------------------------------------------------------
// Weights
#include "pneumonia/w01.h"   
#include "pneumonia/w02.h"   
#include "pneumonia/w03.h"  

// Biases
#include "pneumonia/b01.h"   
#include "pneumonia/b02.h"   
#include "pneumonia/b03.h"   

// ------------------------------------------------------------
// Serial RX protocol settings
// ------------------------------------------------------------
static const uint16_t RX_TIMEOUT_MS = 3000;

static const uint16_t IMG_W = 64;
static const uint16_t IMG_H = 64;
static const uint16_t IMG_C = 3;
static const uint16_t IMG_SIZE = IMG_W * IMG_H * IMG_C; // CHW bytes: C planes stacked

// Uncomment if you want input normalized to [0,1]
#define NORMALIZE_0_1

// ------------------------------------------------------------
// Buffers
// ------------------------------------------------------------
// Max activation in this net is 64 * 64 * 8.
static const uint16_t MAX_FEAT_FLOATS = (uint16_t)64 * 64 * 8;  

static float *A = nullptr;   // ping
static float *B = nullptr;   // pong

static uint8_t RX_BYTES[IMG_SIZE];

// Forward decl
static bool recv_exact(uint8_t *dst, size_t n, unsigned long timeout_ms);
static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n);

static void alloc_buffers()
{
  A = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));
  B = (float *)malloc(MAX_FEAT_FLOATS * sizeof(float));

  if (!A || !B) {
    Serial.println(F("ERROR: malloc failed (out of RAM)"));
    while (true) delay(1000);
  }
}

// ------------------------------------------------------------
// Inference
// ------------------------------------------------------------
void predict()
{
  const unsigned long t0 = micros();

  // ---- No Pooling ----
  Pool none{}; none.M = 1; none.T = 1;
  Pool v1{}; v1.M = 2; v1.T = 2;

  // ---- Stem: Conv3x3 (3->8) + BN + ReLU ----
  ConvMem c1{};
  c1.K = 3; c1.P = 1; c1.S = 1;
  c1.weight = w01;
  c1.bias   = b01;
  c1.act    = ACT_NONE;

  ConvMem c2{};
  c2.K = 3; c2.P = 0; c2.S = 1;
  c2.weight = w02;
  c2.bias   = b02;
  c2.act    = ACT_NONE;

  FCNMem head{};
  head.weight = w03;
  head.bias = b03;
  head.act = ACT_NONE;
  
  // Ping-pong buffers
  
  uint16_t V = 0;
  V = noodle_conv_float(A, 3, 8, B, 64, c1, none, nullptr); // check if V == 64
  V = noodle_conv_float(B, 8, 8, A, V, c2, none, nullptr); // check if V == 60
  V = noodle_valid_max_pool(A, 2, 2, v1); // check if V == 30 
  V = noodle_flat(B, A, V, 8); // check if V == 7200 
  V = noodle_fcn(A, V, 1, B, head, nullptr);
  
  // In-place logit
  noodle_logit(B, 1);

  // Argmax
  uint16_t pred;
  if (B[0] < 0.5) pred = 0; else pred = 1;

  const float et = (float)(micros() - t0) * 1e-6f;

  // Python-friendly:
  // PRED <digit> <seconds> <p_max>
  Serial.print(F("PRED "));
  Serial.print(pred);
  Serial.print(' ');
  Serial.print(et, 4);
  Serial.print(' ');
  Serial.print(B[0], 4);
  
  Serial.println();
}

// ------------------------------------------------------------
// Arduino
// ------------------------------------------------------------
void setup()
{
  Serial.begin(115200);
  delay(200);
  while (Serial.available()) Serial.read();

  alloc_buffers();

  Serial.println(F("READY"));
  // Wait for the first frame from the host.
}

void loop()
{
  if (!recv_exact(RX_BYTES, IMG_SIZE, RX_TIMEOUT_MS)) {
    Serial.println(F("READY"));
    return;
   }
  bytes_to_float_image(RX_BYTES, A, IMG_SIZE);
  predict();
}

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------
static bool recv_exact(uint8_t *dst, size_t n, unsigned long timeout_ms)
{
  unsigned long t0 = millis();
  size_t got = 0;

  while (got < n) {
    if ((millis() - t0) > timeout_ms) return false;

    int avail = Serial.available();
    if (avail <= 0) { delay(1); continue; }

    int r = Serial.readBytes((char *)(dst + got), n - got);
    if (r > 0) got += (size_t)r;
  }
  return true;
}

static void bytes_to_float_image(const uint8_t *src, float *dst, size_t n)
{
#ifdef NORMALIZE_0_1
  const float inv = 1.0f / 255.0f;
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i] * inv;
#else
  for (size_t i = 0; i < n; i++) dst[i] = (float)src[i];
#endif
}
